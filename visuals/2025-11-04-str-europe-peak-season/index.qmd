---
title: "Short-term rental market peak season in Europe"
date: "2025-11-12"
categories: [STR, Europe, occupancy]
image: plots/thumb.svg
description: "Peak occupancy in Europe's top 25 largest short-term rental markets in 2024 based on AirDNA data"
format: html
execute:
  dir: project
  echo: false
  output: false
---

```{r echo=FALSE, output=FALSE}
#| cache: false

# Load required packages
library(tidyverse)

project_path <- file.path("visuals", "2025-11-04-str-europe-peak-season")

# List all CSV files
files <- list.files(paste0(project_path, "/data"), pattern = "\\.csv$", full.names = TRUE)

# Extract ISO2 from filenames (e.g., "market_summary_ES.csv" -> "ES")
file_key <- tibble(
  file = files,
  ISO2 = toupper(stringr::str_match(files, paste0(project_path, "/data/market-summary-([A-Za-z]{2})\\.csv"))[,2])
)

# Read lookup table
iso_lookup <- read_csv("lookups/country_ISO_codes.csv", show_col_types = FALSE) |>
  rename(ISO2 = "Code") |>
  rename(country = "Name")

# Read UNWTO country → region mapping

encoding <- guess_encoding("lookups/unwto_country_region_mapping.csv")["encoding"]

unwto_map <- read_csv("lookups/unwto_country_region_mapping.csv",
                      show_col_types = FALSE,
                      locale = locale(encoding = paste(encoding))) %>%
  janitor::clean_names() %>%
  rename(
    world_region = region,      # rename for clarity
    world_subregion = subregion # keep subregion if you want to facet later
  ) %>%
  mutate(
    country = trimws(country),
    world_region = trimws(world_region)
  )

# Add ISO2 to UNWTO via countrycode, then patch edge cases ---
library(countrycode)

unwto_map <- unwto_map %>%
  mutate(
    ISO2 = countrycode(country, origin = "country.name", destination = "iso2c")
  )

# Manual patches for the known problematic names
fix_iso <- tribble(
  ~country,                                        ~ISO2,
  "Bolivia, Plurinational State of",               "BO",
  "Curaçao",                                       "CW",
  "Korea, Republic of",                            "KR",
  "Lao People's Democratic Republic",              "LA",
  "Macedonia, the Former Yugoslav Republic of",    "MK",  # (North Macedonia; ISO2 still MK)
  "Turkey",                                        "TR",  # or "Türkiye" -> TR
  "Taiwan, Province of China",                     "TW",
  "Tanzania, United Republic of",                  "TZ",
  "Venezuela, Bolivarian Republic of",             "VE"
)

unwto_map <- unwto_map %>%
  left_join(fix_iso, by = "country", suffix = c("", "_fix")) %>%
  mutate(ISO2 = coalesce(ISO2_fix, ISO2)) %>%
  select(-ISO2_fix)

unwto_map <- unwto_map %>% bind_rows(tibble(country = "Europe",
                               world_region = "Europe",
                               world_subregion = NA,
                               ISO2 = "EU"))

# (Optional) sanity check: which UNWTO rows still lack ISO2?
still_na <- unwto_map %>% filter(is.na(ISO2))
if (nrow(still_na)) {
  warning("UNWTO rows without ISO2: ", paste(still_na$country, collapse = ", "))
}


# Helper function to read a single file and tag ISO2
read_one <- function(path, iso2) {
  
  country_name <- unwto_map |> 
    filter(ISO2 == iso2) |> 
    pull(country)
  
  read_csv(path, show_col_types = FALSE) |>
    janitor::clean_names() |>
    mutate(ISO2 = iso2, country = country_name)
}

# Read and combine all files using modern purrr syntax
all_data <- map2(file_key$file, file_key$ISO2, read_one) |>
  list_rbind()
```

```{r}
library(lubridate)

all_data <- all_data %>%
  mutate(month = month(date, label = TRUE, abbr = TRUE)) %>%
  relocate(month, .after = date)

```

```{r}
# Add world_region to all_data (join by country) ---
# (Assumes all_data already has a 'country' column; if not, join by ISO2 if present in the mapping)

all_data <- all_data %>%
  left_join(unwto_map %>% select(ISO2, world_region, world_subregion), by = "ISO2")

# verify coverage
missing_after_join <- all_data %>% filter(is.na(world_region)) %>% distinct(ISO2)
if (nrow(missing_after_join)) {
  warning("No UNWTO region for ISO2: ", paste(missing_after_join$ISO2, collapse = ", "))
}

# Normalize occupancy
all_data <- all_data %>%
  group_by(country) %>%
  mutate(occ_norm = (occupancy - min(occupancy, na.rm = TRUE)) /
                    (max(occupancy, na.rm = TRUE) - min(occupancy, na.rm = TRUE))) %>%
  # mutate(occ_norm_index = occupancy / max(occupancy, na.rm = TRUE)) %>% # Index-to-peak normalization (relative to annual max)
  # mutate(occ_z = (occupancy - mean(occupancy, na.rm = TRUE)) /
  #                sd(occupancy, na.rm = TRUE)) %>% # Z-score standardization
  # mutate(occ_share = occupancy / sum(occupancy, na.rm = TRUE)) %>% # Share of yearly total
  ungroup()

# Top 25 European countries (>10k average listings in 2024)
europe_top_25 <- all_data %>% filter(world_region == "Europe") %>% group_by(country) %>%
    summarise(average_listings = mean(active_listings)) %>% 
    arrange(desc(average_listings)) %>%
    # mutate(rank = 1:40)
    top_n(25) %>% pull(country)

# Create folder for generated datasets
if (!dir.exists(paste0(project_path, "/data/derived")))
dir.create(paste0(project_path, "/data/derived"), recursive = TRUE)

# Save combined dataset
write_csv(all_data, paste0(project_path, "/data/derived/combined_countries.csv"))
```


```{r}
library(forcats)

# Drop unnecessary columns and convert to wide format
europe_wide <- all_data %>%
    filter(country %in% europe_top_25) %>% 
    select(month, country, occ_norm) %>% 
    pivot_wider(names_from = month, values_from = occ_norm) 

# Compute average per month  
europe_avg <- europe_wide %>%
    summarise(across(Jan:Dec, ~ mean(.x, na.rm = TRUE))) %>%
    mutate(country = "Europe")
    
# Append the new row to the existing dataframe
europe_wide <- bind_rows(europe_wide, europe_avg) %>%
    relocate(country)  # move 'country' to the first column

# Compute combined Jul and Aug occupancy score per country
country_rank <- europe_wide %>% 
    rowwise() %>% 
    summarise(country = country,
              month_choice = sum(c(Jul))) %>% # originally a sum of Jul and Aug
    arrange(month_choice) %>% 
    mutate(country = factor(country, levels = country))

# Need to move Europe as the last level
other_levels <- levels(country_rank$country)[levels(country_rank$country) != "Europe"]
new_levels <- c(other_levels, "Europe")

country_rank <- country_rank %>% mutate(country = factor(country, levels = new_levels))

# Convert data frame back to long format for use in ggplot
europe_long <- europe_wide %>% 
    pivot_longer(cols = Jan:Dec, names_to = "month", values_to = "occ_norm") %>% 
    mutate(month = factor(month, levels = month.abb),
           group = case_when(
               country == "Europe" ~ "Europe",
               .default = "Other"
           ))

# Add back an iso2 column to match the country flag codes
europe_long <- europe_long %>% 
  left_join(unwto_map %>% select(country, ISO2), by = "country") %>% 
  mutate(country = factor(country, levels = new_levels))
  
```


```{r}
library(magick)
library(rsvg)
library(dplyr)
library(purrr)
library(glue)

# --- Configuration ---
dest_folder <- paste0(project_path, "/data/country_flags")

if (!dir.exists(dest_folder)) {
  dir.create(dest_folder)
  message(paste0("'", dest_folder, "'", " was created"))
}

country_flags <- tibble(ISO2 = unique(europe_long$ISO2),
                        flag_url = paste0("https://flagicons.lipis.dev/flags/4x3/",
                                          tolower(unique(europe_long$ISO2)),
                                          ".svg")) %>% 
                                              left_join(unwto_map %>%
                                                 select(country, ISO2), by = "ISO2") %>% 
                                                   mutate(country = factor(country, levels = new_levels))

country_flags <- country_flags %>%
                    mutate(png_file = paste0(file.path(dest_folder, tolower(ISO2)), ".png"))

# Check if the folder exists OR contains files (e.g., more than 5 PNGs)
if (!dir.exists(dest_folder) || length(list.files(dest_folder, pattern = "\\.png$")) == 0) {
    message("Flag folder not found or incomplete. Starting download and conversion...")


    flag_arguments <- country_flags %>%
      transmute(
        # 1) URL of the SVG flag (4x3 aspect ratio)
        url = flag_url,
    
        # 2) Two-letter lowercase country code (ISO2)
        iso2_code = tolower(ISO2),
    
        # 3) Local output path for the circular PNG
        dest_path = file.path(dest_folder, paste0(tolower(ISO2), ".png"))
      )


    ################
    # Circular flags
    ################
  
    # # Build a circular mask as SVG (white circle on black), render with rsvg
    # .make_circle_mask <- function(d_px) {
    #   svg <- glue(
    #     "<svg xmlns='http://www.w3.org/2000/svg' width='{d_px}' height='{d_px}' viewBox='0 0 {d_px} {d_px}'>
    #        <rect x='0' y='0' width='{d_px}' height='{d_px}' fill='black'/>
    #        <circle cx='{d_px/2}' cy='{d_px/2}' r='{d_px/2}' fill='white'/>
    #      </svg>"
    #   )
    #   raw_png <- rsvg_png(charToRaw(svg), width = d_px, height = d_px)
    #   image_read(raw_png)
    # }
    # 
    # # Render 4:3 SVG flag -> square -> apply circular mask -> save PNG with alpha
    # circular_crop_and_save <- function(url, iso2_code, dest_path, px = 1400) {
    #   # 1) Render the 4:3 flag crisply
    #   raw_png <- rsvg_png(url, width = px, height = round(px * 3/4))
    #   img <- image_read(raw_png)
    # 
    #   # 2) Centered square crop (uses full height for 4:3)
    #   info <- image_info(img)
    #   d <- min(info$width, info$height)
    #   x_off <- floor((info$width  - d) / 2)
    #   y_off <- floor((info$height - d) / 2)
    #   square <- image_crop(img, sprintf("%dx%d+%d+%d", d, d, x_off, y_off))
    # 
    #   # 3) Build the mask (white=keep, black=transparent)
    #   mask <- .make_circle_mask(d)
    # 
    #   # 4) Apply mask → true circle with transparent corners
    #   # Prefer CopyOpacity; if your magick build is quirky, try DstIn.
    #   circ <- image_composite(square, mask, operator = "CopyOpacity")
    #   # circ <- image_composite(square, mask, operator = "DstIn")  # <- fallback
    # 
    #   # 5) Save PNG (RGBA)
    #   image_write(circ, path = dest_path, format = "png")
    # }
    # 
    # purrr::pwalk(flag_arguments, circular_crop_and_save)
  
    ######################################################
    # Circular flags + change white color to desired color
    ######################################################
  
    # ---------- Helpers ----------
    # 1) Make a circular (white) mask as SVG and rasterize it
    .make_circle_mask <- function(d_px) {
      svg <- glue(
        "<svg xmlns='http://www.w3.org/2000/svg' width='{d_px}' height='{d_px}' viewBox='0 0 {d_px} {d_px}'>
           <rect width='100%' height='100%' fill='black'/>
           <circle cx='{d_px/2}' cy='{d_px/2}' r='{d_px/2}' fill='white'/>
         </svg>"
      )
      image_read(rsvg_png(charToRaw(svg), width = d_px, height = d_px))
    }
  
    # 2) Replace exact white fills (and optionally strokes) in raw SVG text
    recolor_svg_white <- function(svg_text, new_hex = "#EEEEEE", replace_stroke = FALSE) {
      col <- toupper(new_hex)
      if (!grepl("^#", col)) col <- paste0("#", col)
  
      # Build patterns: attribute forms (fill="white"), (stroke="#fff") and style forms (fill:#fff;)
      parts <- c("fill", if (replace_stroke) "stroke" else NULL)
      attr_pat <- sprintf("(?i)\\b(%s)\\s*=\\s*\"\\s*(?:#fff(?:fff)?|white)\\s*\"", paste(parts, collapse="|"))
      attr_rep <- sprintf("\\1=\"%s\"", col)
  
      style_pat <- sprintf("(?i)\\b(%s)\\s*:\\s*(?:#fff(?:fff)?|white)\\b", paste(parts, collapse="|"))
      style_rep <- sprintf("\\1:%s", col)
  
      # Apply both replacements
      out <- gsub(attr_pat, attr_rep, svg_text, perl = TRUE)
      out <- gsub(style_pat, style_rep, out, perl = TRUE)
      out
    }
  
    # ---------- Main ----------
    # Render 4:3 SVG flag -> (optional) recolor exact whites in SVG -> square crop -> circular mask -> PNG
    circular_crop_and_save <- function(
      url, iso2_code, dest_path,
      px = 1400,
      white_hex = NULL,        # e.g. "#EEEEEE" to recolor exact whites in the SVG
      replace_stroke = FALSE   # set TRUE if you also want white strokes recolored
    ) {
      # 1) Load SVG text from URL
      svg_text <- paste(readLines(url, warn = FALSE), collapse = "\n")
  
      # 2) Optionally recolor exact white tokens in the SVG DOM
      if (!is.null(white_hex)) {
        svg_text <- recolor_svg_white(svg_text, new_hex = white_hex, replace_stroke = replace_stroke)
      }
  
      # 3) Rasterize the (possibly modified) SVG at 4:3
      raw_png <- rsvg_png(charToRaw(svg_text), width = px, height = round(px * 3/4))
      img <- image_read(raw_png)
  
      # 4) Centered square crop (uses full height for 4:3)
      info <- image_info(img)
      d <- min(info$width, info$height)
      x_off <- floor((info$width  - d) / 2)
      y_off <- floor((info$height - d) / 2)
      square <- image_crop(img, sprintf("%dx%d+%d+%d", d, d, x_off, y_off))
  
      # 5) Apply circular alpha
      mask <- .make_circle_mask(d)
      circ <- image_composite(square, mask, operator = "CopyOpacity")
  
      # 6) Save PNG with transparency
      image_write(circ, path = dest_path, format = "png")
    }
  
  
    # # 1) Keep original colors, just circle-crop
    # purrr::pwalk(flag_arguments, ~ circular_crop_and_save(..1, ..2, ..3, px = 1600))
  
    # 2) Circle-crop AND recolor white fills to light gray (keeps strokes white)
    purrr::pwalk(flag_arguments, ~ circular_crop_and_save(..1, ..2, ..3,
                                                         px = 1600,
                                                         white_hex = "#EEEEEE",
                                                         replace_stroke = FALSE))
} else {
    message("Flags already downloaded. Skipping process.")
}

# Add coordinates for flags
country_flags <- country_flags %>% 
                  mutate(x_pos = -0.21,
                         y_pos = as.numeric(country),
                         group = case_when(
                                           country == "Europe" ~ "Europe",
                                           .default = "Other"
                                          ),
                         y_pos = if_else(country == "Europe",
                                         1,           
                                         y_pos        
                                        )
                        )
```


```{r}
library(showtext)

font_choice <- "Momo Trust Sans"

font_add_google(font_choice, db_cache = FALSE)
showtext_auto()

```



```{r}
# library(heatmaply)
library(ggtext)
library(viridisLite)
library(glue)
library(ggimage)


# labels for top of chart
top_labels <- expand_grid(
  month  = levels(europe_long$month),
  group  = "Europe"
) %>%
  mutate(label = month)

# Find hex color of max value of 
col_max <- tail(plasma(256), 1)   # yellow end of the scale

# title_html <- glue(
#   "July and August are ",
#   "<span style='background-color:{col_max}; padding:2px 4px; display: inline-block;'>",
#   "peak months</span> in all of Europe’s",
#   "<br/>top markets"  # use <br/> with element_markdown
# )

title_html <- paste0("July and August are peak months in both Northern",
                     "\n", "and Southern European short-term rental markets")

subtitle_html <- paste0("Normalized monthly occupancy by country (Jan–Dec 2024)")

annotation_text_data <- data.frame(
  x_pos = 13.85, 
  y_pos = 22, 
  group = "Other",
  label = paste0("January is the month", "\n",
                                "with the lowest occupancy,", "\n",
                                "followed by November"),
  color = "grey30",
  font_size = 3.5
)

annotation_text_data_peak <- data.frame(
  x_pos = 13.85, 
  y_pos = 1, 
  group = "Europe",
  label = paste0("Peak months"),
  color = "grey30",
  font_size = 3.5
)

# 1. Define the number of months (12)
months_factor_levels <- levels(europe_long$month)
month_names <- months_factor_levels[1:12] # Get all 12 month names

# 2. Define the large Y-position for the invisible row (e.g., 5 or 10)
# This will push the plot's coordinate system boundary up from y=1 to y=5 (or 10)
DUMMY_Y_POSITION <- 2 

# 3. Create the dummy data frame
dummy_data_y_expansion <- tibble(
  # Include all columns necessary for the geom and faceting
  country = "", 
  month = factor(month_names, levels = months_factor_levels),
  occ_norm = NA_real_, # Invisible data
  group = "Europe",    # Belongs to the top facet
  ISO2 = "EU",
  # Set the Y position to the expanded limit
  dummy_y_pos = DUMMY_Y_POSITION 
)

rectangle <- function(start_month, end_month = NA){
  
  if(missing(end_month)) end_month <- start_month
  
  start <- which(levels(europe_long$month) == start_month) - 0.5
  end <- which(levels(europe_long$month) == end_month) + 0.5
  
  # 1. Data for the TOP Facet ("Europe") - Fixed Height
  rect_top_data <- data.frame(
  group = "Europe",
  xmin = start,
  xmax = end,
  ymin = 0.5,  # Covers the 'Europe' row (which is at y=1)
  ymax = 1.5   # Stops exactly at the top of the 'Europe' tile
)
  
  # 2. Data for the BOTTOM Facet ("Other") - Full Height
  rect_bottom_data <- data.frame(
  group = "Other",
  xmin = start,
  xmax = end,
  ymin = 0.5, # Goes to the bottom boundary of the facet
  ymax = nrow(country_flags) - 0.5   # Goes to the top boundary of the facet
)
  
  # Combine them into a single data frame
  return(bind_rows(rect_top_data, rect_bottom_data))
  
}

rect_months_Jul_Aug <- rectangle(start_month = "Jul", end_month = "Aug")
rect_months_Jan <- rectangle("Jan")
rect_months_Nov <- rectangle("Nov")

base_size <- 12

p <- ggplot(europe_long, aes(x = month, y = country, fill = occ_norm)) +
        geom_tile() +
        geom_tile(data = dummy_data_y_expansion, 
              aes(x = month, y = country), fill = NA) + # Use alpha=0 or fill=NA to hide it
        facet_grid(group ~ ., scales = "free_y", space = "free_y") +
        # scale_fill_gradient(low = "#deebf7", high = "#192951") +
        scale_fill_viridis_c(option = "plasma", direction = 1, name = "Normalized\nOccupancy (0–1)",) +
        # scale_fill_gradientn(colors = heatmaply::cool_warm(500), limits = c(0,1)) +  # cool-warm scale
        #coord_fixed() +
        labs(
          x = NULL, y = NULL,
          title = title_html,
          subtitle = subtitle_html,
          caption = "Data source: AirDNA (2025)"
        ) +

        geom_rect(
          data = rect_months_Jul_Aug,
          aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
          color = "black",
          fill = NA,
          linewidth = 0.65,
          inherit.aes = FALSE # Essential when using external data
        ) +
  
          geom_rect(
          data = rect_months_Jan,
          aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
          color = "black",
          fill = NA,
          linewidth = 0.65,
          # linetype = 2,
          inherit.aes = FALSE # Essential when using external data
        ) +
  
            geom_rect(
          data = rect_months_Nov,
          aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
          color = "black",
          fill = NA,
          linewidth = 0.65,
          # linetype = 2,
          inherit.aes = FALSE # Essential when using external data
        ) +
  
        scale_x_discrete(expand = expansion(mult = c(0.15, 0.05))) +
        # scale_y_discrete(expand = expansion(mult = c(0, 0.1))) +
                         
        geom_text(data = top_labels, aes(x = month, y = DUMMY_Y_POSITION - 0.5, label = label),
          inherit.aes = FALSE, vjust = -0.75, size = 3.2, family = font_choice,
          colour = "grey30") +
  
        # Layer 1: Flag for the "Europe" facet
        geom_image(
          data = country_flags %>% filter(country == "Europe"), # Only contains 'Europe' row
          aes(x = x_pos, y = y_pos, image = png_file),
          size = 0.36,
          asp = 1,
          inherit.aes = FALSE
        ) +
      
        # Layer 2: Flags for the "Other" facet
        geom_image(
          data = country_flags %>% filter(!country == "Europe"), # Contains all other country rows
          aes(x = x_pos, y = y_pos, image = png_file),
          size = 0.03,
          asp = 1,
          inherit.aes = FALSE
        ) +
        geom_curve(data = tibble(group = "Other", x = 13.65, y = 22, xend = 1.62, yend = 19),
            aes(x = x, y = y, xend = xend, yend = yend),
          arrow = arrow(length = unit(0.35, "cm"), angle = 23, type = "closed"),
          color = "grey10",
          # size = 0.4,
          angle = 82,
          linewidth = 0.5,
          curvature = -0.25,
          inherit.aes = FALSE
        ) +
        geom_curve(data = tibble(group = "Other", x = 13.65, y = 22, xend = 11.62, yend = 19),
          aes(x = x, y = y, xend = xend, yend = yend),
          arrow = arrow(length = unit(0.35, "cm"), angle = 23, type = "closed"),
          color = "grey10",
          # size = 0.4,
          angle = 40,
          linewidth = 0.5,
          curvature = -0.3,
          inherit.aes = FALSE
        ) +
        geom_curve(data = tibble(group = "Europe", x = 13.65, y = 1, xend = 8.62, yend = 0.43),
          aes(x = x, y = y, xend = xend, yend = yend),
          arrow = arrow(length = unit(0.35, "cm"), angle = 23, type = "closed"),
          color = "grey10",
          # size = 0.4,
          angle = 90,
          linewidth = 0.5,
          curvature = -0.275,
          inherit.aes = FALSE
        ) +
        geom_text(
            data = annotation_text_data,
            aes(x = x_pos, y = y_pos, label = label),
            color = annotation_text_data$color,
            size = annotation_text_data$font_size,
            hjust = 0, # Left-align the text at the x_pos
            fontface = "plain",
            inherit.aes = FALSE
          ) +
          geom_text(
            data = annotation_text_data_peak,
            aes(x = x_pos, y = y_pos, label = label),
            color = annotation_text_data$color,
            size = annotation_text_data$font_size,
            hjust = 0, # Left-align the text at the x_pos
            fontface = "bold",
            inherit.aes = FALSE
          ) +
        coord_cartesian(clip = "off", xlim = c(1, 12.5)) +
        theme_minimal(base_family = font_choice, base_size = 12) +
        theme(
          panel.grid = element_blank(),
          panel.spacing.y = unit(10, "pt"),
          # strip.text.y = element_text(face = "bold", angle = 0),
          strip.text = element_blank(),      # hides the panel text labels
          strip.background = element_blank(), # removes the background panel
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.text.y = element_text(hjust = 1, margin = margin(r = 1.8)),
          plot.title.position = "plot",  # ensures alignment relative to full plot
          plot.title = element_text(hjust = 0, face = "bold", margin = margin(b = 5),
                                    lineheight = 1, size = rel(1.6)), # left-align title
          plot.subtitle = element_text(hjust = 0, margin = margin(t = 3, b = 16),
                                       size = rel(1)), # left-align subtitle
          plot.caption.position = "plot",
          plot.caption = element_text(hjust = 0, vjust = -2.8, colour = "grey50"),
          legend.title = element_text(lineheight = 1, margin = margin(b = 20, unit = "pt")),
          legend.margin = margin(l = 0),
          plot.margin = margin(t = 5.5, r = 21, b = 5.5, l = 5.5, unit = "pt")
        )

# Save thumbnail for homepage listing

if (!dir.exists(paste0(project_path, "/plots")))
dir.create(paste0(project_path, "/plots"), recursive = TRUE)

plot_path <- paste0(project_path, "/plots", "/thumb.svg")

ggsave(plot_path, p, width = 6.85, height = 8.2)
```

![](plots/thumb.svg){width=100%}
```{r}
europe_long <- europe_long %>%
                mutate(line_color = case_when(
                                              group == "Europe" ~ "#00009900",
                                              country %in% c("Sweden", "Norway", "Switzerland", "Austria") ~ "#4c6a9c",
                                              country %in% c("Greece", "Cyprus", "Spain", "Italy") ~ "#c15065",
                                              .default = "grey90"
                                             ),
                      line_width = case_when(
                                             line_color != "grey90" ~ 0.8, # <- Use != instead of !...==
                                             .default = 0.4
                                            ),
                      line_type = case_when(
                                              country == "Europe" ~ 2,
                                              .default = 1
                      )
                )

countries_on_top <- c("Europe", "Switzerland", "Greece", "Sweden", "Norway", "Switzerland", "Austria",
                      "Cyprus", "Spain", "Italy")

europe_long <- europe_long %>%
                mutate(is_on_top = ifelse(country %in% countries_on_top, 1, 0)) %>% 
                  arrange(is_on_top, country, month)

new_country_levels <- unique(europe_long$country)

europe_long <- europe_long %>% mutate(country = factor(country, levels = new_country_levels))

# occ_by_country <- europe_long %>% filter(month == "Dec") %>% select(country, occ_norm, ISO2)
# 
# if(!has_name(country_flags, "occ_norm")){
#   country_flags <- country_flags %>%
#                   left_join(occ_by_country %>% select(ISO2, occ_norm), by = c("ISO2"))
# }
# 
# country_flags <- country_flags %>% mutate(x_pos = 12.35, y_pos = occ_norm)

# Define the colors and labels for the legend
legend_data <- tibble(
  label = rep(c("Northern markets", "Southern markets"), each = 2), # Repeat each label twice
    color = rep(c("#4c6a9c", "#c15065"), each = 2),
  x_start = rep(c(1, 2), times = 2), # Create two distinct dummy x-coordinates
  y_start = rep(c(1, 1), times = 2)  # Use the same dummy y-coordinate
)

annotation_1 <- data.frame(
  x_pos = 3.85, 
  y_pos = 1.12, 
  label = paste0("<b style='color: #4c6a9c;'>Northern markets</b> exhibit peak occupancy", "<br>",
                 "three times a year, aligning with the February", "<br>",
                 "ski season, the summer break, and December holidays."),
  color = "grey30",
  font_size = 3.5
)

annotation_2 <- data.frame(
  x_pos = 6.62, 
  y_pos = 0.102, 
  label = paste0("<b style='color: #c15065;'>Southern markets</b> primarily rely on summer", "<br>",
                 "tourism, enjoying a prolonged high-occupancy", "<br>", "period from June through September,",
                 "<br>", "maintaining medium-strong occupancy levels", "<br>",
                 "during the shoulder seasons of Spring and early Autumn."),
  color = "grey30",
  font_size = 3.5
)

annotation_markers <- tibble(
  x_coord = c(2, 7, 12, 8),
  # Y coordinate is set slightly below the top of the chart (y=1)
  y_coord = c(0.995, 1.05, 0.93, 1.05), 
  
  # Rich Text Labels with HTML/CSS Formatting
  # Using Times New Roman as a common Serif fallback
  label_text = c(
    "<b style='font-family:\"Noto Serif\";'>I</b>",
    "<b style='font-family:\"Noto Serif\";'>II</b>",
    "<b style='font-family:\"Noto Serif\";'>III</b>",
    "<b style='font-family:\"Noto Serif\";'>I</b>"
  ),
  
  # Text Color
  text_color = c("#4c6a9c", "#4c6a9c", "#4c6a9c", "#c15065"),
  
  # ggtext Aesthetics (kept constant for all points)
  hjust_val = rep(0.5, 4), # Center horizontally
  vjust_val = rep(0.55, 4) # Adjust slightly down for visual centering
)

plot_note_data <- tibble(
    x_pos = 0.45,
    y_pos = -0.19, # -0.19
    note_text = "<span style='font-family:\"Momo Trust Sans\";'><b>Note</b>: Northern markets include Sweden, Norway, Switzerland, Austria. Southern markets inlcude Italy, Spain, Greece, Cyprus.<span>"
)

```


```{r}
library(showtext)

font_choice <- "Momo Trust Sans"

font_choice_labels <- "Noto Serif"

third_font <- "Montserrat"

# adding fonts one-by-one, since combining seems not to work despite no error
font_add_google(font_choice) #db_cache = FALSE
font_add_google(font_choice_labels)
font_add_google(third_font)

showtext_auto()

# # font check
# print(font_families())
```

```{r}
library(ggtext)

p <- ggplot(europe_long, aes(x = month, y = occ_norm)) +
        geom_line(aes(group = country, color = line_color, linewidth = line_width)) +
        # Layer for legend
        geom_line(
            data = legend_data, 
            # Only map 'color' to the aesthetic
            aes(x = x_start, y = y_start, color = color), 
            linewidth = 0, 
            alpha = 0,     
            inherit.aes = FALSE,
            key_glyph = "path"
          ) +
        scale_color_identity(
            name = NULL, 
            guide = "legend",
            labels = legend_data$label[c(TRUE, FALSE)], # Select only one label per pair
            breaks = legend_data$color[c(TRUE, FALSE)]  # Select only one color per pair
          ) +
        guides(linetype = "none") +
        # scale_color_identity() +
        scale_linewidth_identity() +
        scale_linetype_identity() +
        coord_cartesian(xlim = c(1.5, 11.5), ylim = c(0, 1.12), clip = "off") +
        theme_minimal(base_family = font_choice, base_size = 14) +
        labs(
             x = NULL, y = NULL,
             title = paste0("Divergent seasonal peaks: occupancy patterns in <b style='color: #4c6a9c;'>Northern</b>",
                            "<br>", 
                            "and <b style='color: #c15065;'>Southern</b> European short-term rental markets"),
             subtitle = paste0("Normalized monthly occupancy by country (Jan–Dec 2024)"),
             caption = paste0("<b>Data source</b>: AirDNA (2025)")
             ) +
        geom_richtext(
            data = annotation_1,
            aes(x = x_pos, y = y_pos, label = label),
            color = annotation_1$color,
            size = annotation_1$font_size,
            hjust = 0.5, # Center-align the text at the x_pos
            fontface = "plain",
            lineheight = 0.85,
            inherit.aes = FALSE,
            fill = NA, 
            label.color = NA,
            label.padding = unit(0.25, "lines"), # Reduce padding around text
          ) +
          geom_richtext(
            data = annotation_2,
            aes(x = x_pos, y = y_pos, label = label),
            color = annotation_2$color,
            size = annotation_2$font_size,
            hjust = 0.5, # Center-align the text at the x_pos
            fontface = "plain",
            lineheight = 0.85,
            inherit.aes = FALSE,
            fill = NA, 
            label.color = NA,
            label.padding = unit(0.25, "lines"), # Reduce padding around text
          ) +
        # Marker Annotations (I, II, III, Red I)
        geom_richtext(
          data = annotation_markers,
          aes(
            x = x_coord,
            y = y_coord,
            label = label_text,
            color = text_color,
            label.color = text_color, 
            hjust = hjust_val,
            vjust = vjust_val
          ),
          # Set the remaining ggtext parameters outside of aes()
          size = 5,
          fill = NA, # No background fill
          label.color = NA, # No border
          label.padding = unit(c(0.2, 0.2, 0.2, 0.2), "lines"), # Symmetrical padding
          inherit.aes = FALSE, # Crucial: prevents inheriting the line aesthetics
          show.legend = FALSE
        ) +
        geom_richtext(
            data = plot_note_data,
            aes(x = x_pos, y = y_pos, label = note_text),
            # size = 3.5,
            color = "grey50", 
            hjust = 0,
            vjust = 1,
            fill = NA, 
            label.color = NA,
            label.padding = unit(0, "lines"),
            inherit.aes = FALSE,
            show.legend = FALSE
        ) +
        scale_y_continuous(
          # Set breaks every 0.25 from 0 to 1
          breaks = seq(0, 1, by = 0.2), 
      
          # # OPTIONAL: Define the display format for the labels (e.g., percentages)
          # labels = scales::percent, 
        ) +
        theme(panel.grid.major.x = element_blank(),
              panel.grid.minor.y = element_blank(),
              panel.grid.major.y = element_line(linetype = 2),
              plot.title.position = "plot",
              strip.background = element_blank(),
              legend.position = c(0.78, 1.04),
              legend.justification = c(0, 1),
              # legend.margin = margin(t = 0, r = 0, b = -10, l = 0, unit = "pt"),
              axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              plot.title = element_markdown(hjust = 0, face = "bold", margin = margin(b = 5),
                                          lineheight = 1, size = rel(1.6)), # left-align title
              plot.subtitle = element_markdown(hjust = 0, margin = margin(t = 3, b = 25),
                                             size = rel(1)), # left-align subtitle
              plot.caption.position = "plot",
              plot.caption = element_markdown(hjust = 0, vjust = 0, colour = "grey50",
                                              margin = margin(t = 35)),
              plot.margin = margin(t = 4.5, r = 21, b = 55, l = 5.5, unit = "pt")
              )

#p
plot_path <- paste0(project_path, "/plots", "/line_chart.svg")

ggsave(plot_path, p, width = 9.3, height = 7.2)
  
```

![](plots/line_chart.svg){width=100%}