---
title: "Short-term rental market peak season by world region"
date: "2025-11-12"
categories: [STR, Europe, occupancy]
image: plots/thumb.svg
description: "Peaks occupancy in Europe's top short-term rental markets in 2024 based on AirDNA data"
format: html
execute:
  dir: project
  echo: false
  output: false
---

```{r echo=FALSE, output=FALSE}
#| cache: false

# Load required packages
library(tidyverse)

project_path <- file.path("visuals", "2025-11-04-str-europe-peak-season")

# List all CSV files
files <- list.files(paste0(project_path, "/data"), pattern = "\\.csv$", full.names = TRUE)

# Extract ISO2 from filenames (e.g., "market_summary_ES.csv" -> "ES")
file_key <- tibble(
  file = files,
  ISO2 = toupper(stringr::str_match(files, paste0(project_path, "/data/market-summary-([A-Za-z]{2})\\.csv"))[,2])
)

# Read lookup table
iso_lookup <- read_csv("lookups/country_ISO_codes.csv", show_col_types = FALSE) |>
  rename(ISO2 = "Code") |>
  rename(country = "Name")

# Read UNWTO country → region mapping

encoding <- guess_encoding("lookups/unwto_country_region_mapping.csv")["encoding"]

unwto_map <- read_csv("lookups/unwto_country_region_mapping.csv",
                      show_col_types = FALSE,
                      locale = locale(encoding = paste(encoding))) %>%
  janitor::clean_names() %>%
  rename(
    world_region = region,      # rename for clarity
    world_subregion = subregion # keep subregion if you want to facet later
  ) %>%
  mutate(
    country = trimws(country),
    world_region = trimws(world_region)
  )

# Add ISO2 to UNWTO via countrycode, then patch edge cases ---
library(countrycode)

unwto_map <- unwto_map %>%
  mutate(
    ISO2 = countrycode(country, origin = "country.name", destination = "iso2c")
  )

# Manual patches for the known problematic names
fix_iso <- tribble(
  ~country,                                        ~ISO2,
  "Bolivia, Plurinational State of",               "BO",
  "Curaçao",                                       "CW",
  "Korea, Republic of",                            "KR",
  "Lao People's Democratic Republic",              "LA",
  "Macedonia, the Former Yugoslav Republic of",    "MK",  # (North Macedonia; ISO2 still MK)
  "Turkey",                                        "TR",  # or "Türkiye" -> TR
  "Taiwan, Province of China",                     "TW",
  "Tanzania, United Republic of",                  "TZ",
  "Venezuela, Bolivarian Republic of",             "VE"
)

unwto_map <- unwto_map %>%
  left_join(fix_iso, by = "country", suffix = c("", "_fix")) %>%
  mutate(ISO2 = coalesce(ISO2_fix, ISO2)) %>%
  select(-ISO2_fix)

unwto_map <- unwto_map %>% bind_rows(tibble(country = "Europe",
                               world_region = "Europe",
                               world_subregion = NA,
                               ISO2 = "EU"))

# (Optional) sanity check: which UNWTO rows still lack ISO2?
still_na <- unwto_map %>% filter(is.na(ISO2))
if (nrow(still_na)) {
  warning("UNWTO rows without ISO2: ", paste(still_na$country, collapse = ", "))
}


# Helper function to read a single file and tag ISO2
read_one <- function(path, iso2) {
  
  country_name <- unwto_map |> 
    filter(ISO2 == iso2) |> 
    pull(country)
  
  read_csv(path, show_col_types = FALSE) |>
    janitor::clean_names() |>
    mutate(ISO2 = iso2, country = country_name)
}

# Read and combine all files using modern purrr syntax
all_data <- map2(file_key$file, file_key$ISO2, read_one) |>
  list_rbind()
```

```{r}
library(lubridate)

all_data <- all_data %>%
  mutate(month = month(date, label = TRUE, abbr = TRUE)) %>%
  relocate(month, .after = date)

```

```{r}
# Add world_region to all_data (join by country) ---
# (Assumes all_data already has a 'country' column; if not, join by ISO2 if present in the mapping)

all_data <- all_data %>%
  left_join(unwto_map %>% select(ISO2, world_region, world_subregion), by = "ISO2")

# verify coverage
missing_after_join <- all_data %>% filter(is.na(world_region)) %>% distinct(ISO2)
if (nrow(missing_after_join)) {
  warning("No UNWTO region for ISO2: ", paste(missing_after_join$ISO2, collapse = ", "))
}

# Normalize occupancy
all_data <- all_data %>%
  group_by(country) %>%
  mutate(occ_norm = (occupancy - min(occupancy, na.rm = TRUE)) /
                    (max(occupancy, na.rm = TRUE) - min(occupancy, na.rm = TRUE))) %>%
  # mutate(occ_norm_index = occupancy / max(occupancy, na.rm = TRUE)) %>% # Index-to-peak normalization (relative to annual max)
  # mutate(occ_z = (occupancy - mean(occupancy, na.rm = TRUE)) /
  #                sd(occupancy, na.rm = TRUE)) %>% # Z-score standardization
  # mutate(occ_share = occupancy / sum(occupancy, na.rm = TRUE)) %>% # Share of yearly total
  ungroup()

# Top 25 European countries (>10k average listings in 2024)
europe_top_25 <- all_data %>% filter(world_region == "Europe") %>% group_by(country) %>%
    summarise(average_listings = mean(active_listings)) %>% 
    arrange(desc(average_listings)) %>%
    # mutate(rank = 1:40)
    top_n(25) %>% pull(country)

# Create folder for generated datasets
if (!dir.exists(paste0(project_path, "/data/derived")))
dir.create(paste0(project_path, "/data/derived"), recursive = TRUE)

# Save combined dataset
write_csv(all_data, paste0(project_path, "/data/derived/combined_countries.csv"))
```


```{r}
library(forcats)

# Drop unnecessary columns and convert to wide format
europe_wide <- all_data %>%
    filter(country %in% europe_top_25) %>% 
    select(month, country, occ_norm) %>% 
    pivot_wider(names_from = month, values_from = occ_norm) 

# Compute average per month  
europe_avg <- europe_wide %>%
    summarise(across(Jan:Dec, ~ mean(.x, na.rm = TRUE))) %>%
    mutate(country = "Europe")
    
# Append the new row to the existing dataframe
europe_wide <- bind_rows(europe_wide, europe_avg) %>%
    relocate(country)  # move 'country' to the first column

# Compute combined Jul and Aug occupancy score per country
country_rank <- europe_wide %>% 
    rowwise() %>% 
    summarise(country = country,
              month_choice = sum(c(Jul))) %>% # originally a sum of Jul and Aug
    arrange(month_choice) %>% 
    mutate(country = factor(country, levels = country))

# Need to move Europe as the last level
other_levels <- levels(country_rank$country)[levels(country_rank$country) != "Europe"]
new_levels <- c(other_levels, "Europe")

country_rank <- country_rank %>% mutate(country = factor(country, levels = new_levels))

# Convert data frame back to long format for use in ggplot
europe_long <- europe_wide %>% 
    pivot_longer(cols = Jan:Dec, names_to = "month", values_to = "occ_norm") %>% 
    mutate(month = factor(month, levels = month.abb),
           group = case_when(
               country == "Europe" ~ "Europe",
               .default = "Other"
           ))

# Add back an iso2 column to match the country flag codes
europe_long <- europe_long %>% 
  left_join(unwto_map %>% select(country, ISO2), by = "country") %>% 
  mutate(country = factor(country, levels = new_levels))
  
```


```{r}
library(magick)
library(rsvg)
library(dplyr)
library(purrr)
library(glue)

# --- Configuration ---
dest_folder <- paste0(project_path, "/data/country_flags")

if (!dir.exists(dest_folder)) {
  dir.create(dest_folder)
  message(paste0("'", dest_folder, "'", " was created"))
}

country_flags <- tibble(ISO2 = unique(europe_long$ISO2),
                        flag_url = paste0("https://flagicons.lipis.dev/flags/4x3/",
                                          tolower(unique(europe_long$ISO2)),
                                          ".svg")) %>% 
                                              left_join(unwto_map %>%
                                                 select(country, ISO2), by = "ISO2") %>% 
                                                   mutate(country = factor(country, levels = new_levels))

country_flags <- country_flags %>%
                    mutate(png_file = paste0(file.path(dest_folder, tolower(ISO2)), ".png"))

# Check if the folder exists OR contains files (e.g., more than 5 PNGs)
if (!dir.exists(dest_folder) || length(list.files(dest_folder, pattern = "\\.png$")) == 0) {
    message("Flag folder not found or incomplete. Starting download and conversion...")


    flag_arguments <- country_flags %>%
      transmute(
        # 1) URL of the SVG flag (4x3 aspect ratio)
        url = flag_url,
    
        # 2) Two-letter lowercase country code (ISO2)
        iso2_code = tolower(ISO2),
    
        # 3) Local output path for the circular PNG
        dest_path = file.path(dest_folder, paste0(tolower(ISO2), ".png"))
      )


    ################
    # Circular flags
    ################
  
    # # Build a circular mask as SVG (white circle on black), render with rsvg
    # .make_circle_mask <- function(d_px) {
    #   svg <- glue(
    #     "<svg xmlns='http://www.w3.org/2000/svg' width='{d_px}' height='{d_px}' viewBox='0 0 {d_px} {d_px}'>
    #        <rect x='0' y='0' width='{d_px}' height='{d_px}' fill='black'/>
    #        <circle cx='{d_px/2}' cy='{d_px/2}' r='{d_px/2}' fill='white'/>
    #      </svg>"
    #   )
    #   raw_png <- rsvg_png(charToRaw(svg), width = d_px, height = d_px)
    #   image_read(raw_png)
    # }
    # 
    # # Render 4:3 SVG flag -> square -> apply circular mask -> save PNG with alpha
    # circular_crop_and_save <- function(url, iso2_code, dest_path, px = 1400) {
    #   # 1) Render the 4:3 flag crisply
    #   raw_png <- rsvg_png(url, width = px, height = round(px * 3/4))
    #   img <- image_read(raw_png)
    # 
    #   # 2) Centered square crop (uses full height for 4:3)
    #   info <- image_info(img)
    #   d <- min(info$width, info$height)
    #   x_off <- floor((info$width  - d) / 2)
    #   y_off <- floor((info$height - d) / 2)
    #   square <- image_crop(img, sprintf("%dx%d+%d+%d", d, d, x_off, y_off))
    # 
    #   # 3) Build the mask (white=keep, black=transparent)
    #   mask <- .make_circle_mask(d)
    # 
    #   # 4) Apply mask → true circle with transparent corners
    #   # Prefer CopyOpacity; if your magick build is quirky, try DstIn.
    #   circ <- image_composite(square, mask, operator = "CopyOpacity")
    #   # circ <- image_composite(square, mask, operator = "DstIn")  # <- fallback
    # 
    #   # 5) Save PNG (RGBA)
    #   image_write(circ, path = dest_path, format = "png")
    # }
    # 
    # purrr::pwalk(flag_arguments, circular_crop_and_save)
  
    ######################################################
    # Circular flags + change white color to desired color
    ######################################################
  
    # ---------- Helpers ----------
    # 1) Make a circular (white) mask as SVG and rasterize it
    .make_circle_mask <- function(d_px) {
      svg <- glue(
        "<svg xmlns='http://www.w3.org/2000/svg' width='{d_px}' height='{d_px}' viewBox='0 0 {d_px} {d_px}'>
           <rect width='100%' height='100%' fill='black'/>
           <circle cx='{d_px/2}' cy='{d_px/2}' r='{d_px/2}' fill='white'/>
         </svg>"
      )
      image_read(rsvg_png(charToRaw(svg), width = d_px, height = d_px))
    }
  
    # 2) Replace exact white fills (and optionally strokes) in raw SVG text
    recolor_svg_white <- function(svg_text, new_hex = "#EEEEEE", replace_stroke = FALSE) {
      col <- toupper(new_hex)
      if (!grepl("^#", col)) col <- paste0("#", col)
  
      # Build patterns: attribute forms (fill="white"), (stroke="#fff") and style forms (fill:#fff;)
      parts <- c("fill", if (replace_stroke) "stroke" else NULL)
      attr_pat <- sprintf("(?i)\\b(%s)\\s*=\\s*\"\\s*(?:#fff(?:fff)?|white)\\s*\"", paste(parts, collapse="|"))
      attr_rep <- sprintf("\\1=\"%s\"", col)
  
      style_pat <- sprintf("(?i)\\b(%s)\\s*:\\s*(?:#fff(?:fff)?|white)\\b", paste(parts, collapse="|"))
      style_rep <- sprintf("\\1:%s", col)
  
      # Apply both replacements
      out <- gsub(attr_pat, attr_rep, svg_text, perl = TRUE)
      out <- gsub(style_pat, style_rep, out, perl = TRUE)
      out
    }
  
    # ---------- Main ----------
    # Render 4:3 SVG flag -> (optional) recolor exact whites in SVG -> square crop -> circular mask -> PNG
    circular_crop_and_save <- function(
      url, iso2_code, dest_path,
      px = 1400,
      white_hex = NULL,        # e.g. "#EEEEEE" to recolor exact whites in the SVG
      replace_stroke = FALSE   # set TRUE if you also want white strokes recolored
    ) {
      # 1) Load SVG text from URL
      svg_text <- paste(readLines(url, warn = FALSE), collapse = "\n")
  
      # 2) Optionally recolor exact white tokens in the SVG DOM
      if (!is.null(white_hex)) {
        svg_text <- recolor_svg_white(svg_text, new_hex = white_hex, replace_stroke = replace_stroke)
      }
  
      # 3) Rasterize the (possibly modified) SVG at 4:3
      raw_png <- rsvg_png(charToRaw(svg_text), width = px, height = round(px * 3/4))
      img <- image_read(raw_png)
  
      # 4) Centered square crop (uses full height for 4:3)
      info <- image_info(img)
      d <- min(info$width, info$height)
      x_off <- floor((info$width  - d) / 2)
      y_off <- floor((info$height - d) / 2)
      square <- image_crop(img, sprintf("%dx%d+%d+%d", d, d, x_off, y_off))
  
      # 5) Apply circular alpha
      mask <- .make_circle_mask(d)
      circ <- image_composite(square, mask, operator = "CopyOpacity")
  
      # 6) Save PNG with transparency
      image_write(circ, path = dest_path, format = "png")
    }
  
  
    # # 1) Keep original colors, just circle-crop
    # purrr::pwalk(flag_arguments, ~ circular_crop_and_save(..1, ..2, ..3, px = 1600))
  
    # 2) Circle-crop AND recolor white fills to light gray (keeps strokes white)
    purrr::pwalk(flag_arguments, ~ circular_crop_and_save(..1, ..2, ..3,
                                                         px = 1600,
                                                         white_hex = "#EEEEEE",
                                                         replace_stroke = FALSE))
} else {
    message("Flags already downloaded. Skipping process.")
}

# Add coordinates for flags
country_flags <- country_flags %>% 
                  mutate(x_pos = -0.21,
                         y_pos = as.numeric(country),
                         group = case_when(
                                           country == "Europe" ~ "Europe",
                                           .default = "Other"
                                          ),
                         y_pos = if_else(country == "Europe",
                                         1,           
                                         y_pos        
                                        )
                        )
```


```{r country-flags}
# library(rsvg)
# 
# country_flags <- tibble(ISO2 = unique(europe_long$ISO2),
#                         flag_url = paste0("https://hatscripts.github.io/circle-flags/flags/",
#                                               tolower(unique(europe_long$ISO2)),
#                                               ".svg")) %>% 
#                 left_join(unwto_map %>% select(country, ISO2), by = "ISO2") %>% 
#                 mutate(country = factor(country, levels = new_levels))
# 
# dest_folder <- paste0(project_path, "/data/country_flags/")
# 
# # Create new folder for flags (inside 'data')
# if (!dir.exists(dest_folder))
# dir.create(dest_folder, recursive = TRUE)
# 
# country_flags <- country_flags %>%
#                     mutate(local_svg_file = paste0(dest_folder, tolower(ISO2), ".svg"),
#                            png_file = paste0(dest_folder, tolower(ISO2), ".png"))
# 
# # Check if the folder exists OR contains files (e.g., more than 5 PNGs)
# if (!dir.exists(dest_folder) || length(list.files(dest_folder, pattern = "\\.png$")) == 0) {
# 
#     message("Flag folder not found or incomplete. Starting download and conversion...")
# 
#     # Iteratively download images from https://hatscripts.github.io/circle-flags/gallery.html
#     # Flags are in SVG
#     purrr::walk2(
#       .x = country_flags$flag_url, # The URLs to download (source)
#       .y = country_flags$local_svg_file, # The file path to save to (destination)
#       .f = download.file,
#       quiet = TRUE,
#       mode = "wb" # Use "wb" (write binary) for images to prevent corruption
#     )
#     
#     # Convert flags from SVG to PNG for plotting with ggplot
#     purrr::walk2(
#       .x = country_flags$local_svg_file,
#       .y = country_flags$png_file,
#       .f = rsvg_png
#     )
#     
#   } else {
#     message("Flags already downloaded. Skipping process.")
# }
# 
# # Add coordinates for flags
# country_flags <- country_flags %>% 
#                   mutate(x_pos = -0.21,
#                          y_pos = as.numeric(country),
#                          group = case_when(
#                                            country == "Europe" ~ "Europe",
#                                            .default = "Other"
#                                           ),
#                         y_pos = if_else(country == "Europe",
#                                         1,           
#                                         y_pos        
#                                        )
#                         )

```

```{r}
# <!-- #| eval: true -->
# <!-- #| cache: true -->
library(showtext)
font_choice <- "Momo Trust Sans"

font_add_google(font_choice, db_cache = FALSE)
showtext_auto()
```



```{r}

# library(heatmaply)
library(ggtext)
library(viridisLite)
library(glue)
library(ggimage)


# labels for top of chart
top_labels <- expand_grid(
  month  = levels(europe_long$month),
  group  = "Europe"
) %>%
  mutate(label = month)

# Find hex color of max value of 
col_max <- tail(plasma(256), 1)   # yellow end of the scale

# title_html <- glue(
#   "July and August are ",
#   "<span style='background-color:{col_max}; padding:2px 4px; display: inline-block;'>",
#   "peak months</spanb> in all of Europe’s",
#   "<br/>top markets"  # use <br/> with element_markdown
# )

title_html <- paste0("July and August are peak months in both Northern",
                     "\n", "and Southern short-term rental markets")

# 1. Define the number of months (12)
months_factor_levels <- levels(europe_long$month)
month_names <- months_factor_levels[1:12] # Get all 12 month names

# 2. Define the large Y-position for the invisible row (e.g., 5 or 10)
# This will push the plot's coordinate system boundary up from y=1 to y=5 (or 10)
DUMMY_Y_POSITION <- 2 

# 3. Create the dummy data frame
dummy_data_y_expansion <- tibble(
  # Include all columns necessary for the geom and faceting
  country = "", 
  month = factor(month_names, levels = months_factor_levels),
  occ_norm = NA_real_, # Invisible data
  group = "Europe",    # Belongs to the top facet
  ISO2 = "EU",
  # Set the Y position to the expanded limit
  dummy_y_pos = DUMMY_Y_POSITION 
)

# Get the month positions for Jul/Aug
jul_pos <- which(levels(europe_long$month) == "Jul") - 0.5
aug_pos <- which(levels(europe_long$month) == "Aug") + 0.5

# 1. Data for the TOP Facet ("Europe") - Fixed Height
rect_top_data <- data.frame(
  group = "Europe",
  xmin = jul_pos,
  xmax = aug_pos,
  ymin = 0.5,  # Covers the 'Europe' row (which is at y=1)
  ymax = 1.5   # Stops exactly at the top of the 'Europe' tile
)

# 2. Data for the BOTTOM Facet ("Other") - Full Height
rect_bottom_data <- data.frame(
  group = "Other",
  xmin = jul_pos,
  xmax = aug_pos,
  ymin = 0.5, # Goes to the bottom boundary of the facet
  ymax = nrow(country_flags) - 0.5   # Goes to the top boundary of the facet
)

# Combine them into a single data frame
rect_data_combined <- bind_rows(rect_top_data, rect_bottom_data)

base_size <- 12

p <- ggplot(europe_long, aes(x = month, y = country, fill = occ_norm)) +
        geom_tile() +
        geom_tile(data = dummy_data_y_expansion, 
              aes(x = month, y = country), fill = NA) + # Use alpha=0 or fill=NA to hide it
        facet_grid(group ~ ., scales = "free_y", space = "free_y") +
        # scale_fill_gradient(low = "#deebf7", high = "#192951") +
        scale_fill_viridis_c(option = "plasma", direction = 1, name = "Normalized\nOccupancy (0–1)",) +
        # scale_fill_gradientn(colors = heatmaply::cool_warm(500), limits = c(0,1)) +  # cool-warm scale
        #coord_fixed() +
        labs(
          x = NULL, y = NULL,
          title = title_html,
          subtitle = "Normalized monthly occupancy by country (Jan–Dec 2024)",
          caption = "Data source: AirDNA (2025)"
        ) +

        geom_rect(
          data = rect_data_combined,
          aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),
          color = "black",
          fill = NA,
          linewidth = 0.65,
          inherit.aes = FALSE # Essential when using external data
        ) +
  
        scale_x_discrete(expand = expansion(mult = c(0.15, 0.05))) +
        # scale_y_discrete(expand = expansion(mult = c(0, 0.1))) +
                         
        geom_text(data = top_labels, aes(x = month, y = DUMMY_Y_POSITION - 0.5, label = label),
          inherit.aes = FALSE, vjust = -0.75, size = 3.2, family = font_choice,
          colour = "grey30") +
  
        # Layer 1: Flag for the "Europe" facet
        geom_image(
          data = country_flags %>% filter(country == "Europe"), # Only contains 'Europe' row
          aes(x = x_pos, y = y_pos, image = png_file),
          size = 0.38,
          asp = 1,
          inherit.aes = FALSE
        ) +
      
        # Layer 2: Flags for the "Other" facet
        geom_image(
          data = country_flags %>% filter(!country == "Europe"), # Contains all other country rows
          aes(x = x_pos, y = y_pos, image = png_file),
          size = 0.03,
          asp = 1,
          inherit.aes = FALSE
        ) +

        theme_minimal(base_family = font_choice, base_size = 12) +
        theme(
          panel.grid = element_blank(),
          panel.spacing.y = unit(10, "pt"),
          # strip.text.y = element_text(face = "bold", angle = 0),
          strip.text = element_blank(),      # hides the panel text labels
          # strip.background = element_blank(), # removes the background panel
          axis.text.x = element_text(angle = 0, hjust = 0.5),
          axis.text.y = element_text(hjust = 1, margin = margin(r = 1.8)),
          plot.title.position = "plot",  # ensures alignment relative to full plot
          plot.title = element_text(hjust = 0, face = "bold", margin = margin(b = 5),
                                    lineheight = 1, size = rel(1.6)), # left-align title
          plot.subtitle = element_text(hjust = 0, margin = margin(t = 3, b = 16),
                                       size = rel(1.2)), # left-align subtitle
          plot.caption.position = "plot",
          plot.caption = element_text(hjust = 0, vjust = -3, colour = "grey50"),
          legend.title = element_text(lineheight = 1, margin = margin(b = 20, unit = "pt")),
          legend.margin = margin(l = 4)
        )

# Save thumbnail for homepage listing

if (!dir.exists(paste0(project_path, "/plots")))
dir.create(paste0(project_path, "/plots"), recursive = TRUE)

plot_path <- paste0(project_path, "/plots", "/thumb.svg")

ggsave(plot_path, p, width = 6.7, height = 8.2)
```

![](plots/thumb.svg){width=100%}
